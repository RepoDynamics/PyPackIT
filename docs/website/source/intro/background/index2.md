# Introduction


## GitHub Social Coding Platform

Software development is becoming a highly collaborative and distributed process \cite{ScaleAndEvolOfCoordNeeds}, with contributors from diverse geographical and temporal coordinates \cite{GlobalSoftEng}. These added social aspects increase project complexity \cite{InfluenceOfSocialAndTechnicalFactors}, requiring high degrees of communication and coordination \cite{UnderstandingCommunitySmells, CollabSoftEngBookChallenges, GlobalSoftDevChallenges}. Consequently, effective collaboration and project management are major challenges in research software development \cite{ConfigManageForLargescaleSciComp}. Cloud-based software hosting services aim to solve such problems \cite{OpenSourceSoftHostingPlatforms}. These so-called social coding platforms (SCPs) offer a transparent mutual environment for communication and collaboration \cite{CharacterizingProjEvolOnSocialCodingPlat, SocialCodingInGitHub}, equipped with crucial software engineering tools, such as distributed version control systems (VCSs) \cite{VCSReview} like \href{https://git-scm.com/}{Git} \cite{BetterSoftwareBetterResearch, BarelySufficientPracticesInSciComp, BestPracticesInBioinfSoftware, 4SimpleRecs, 10RuleForSoftwareInCompBio, SustainableResearchSoftwareHandOver, SurveySEPracticesInScience, BestPracticesForSciComp, QuickGuideToOrgCompBioProjects, WhatMakesCompSoftSuccessful, GoodEnoughPracticesInSciComp, SciSoftDevIsNotOxymoron}. \href{https://github.com}{GitHub}, currently the world’s largest SCP \cite{GitHubOctoverse2023}, is thus one of the most recommended platforms for research software projects \cite{ELIXIRSoftwareManagementPlan, BetterSoftwareBetterResearch, 4SimpleRecs, 10RuleForSoftwareInCompBio, BestPracticesForSciComp, 10SimpleRulesGitAndGitHub}, providing special features for scientific applications and offering free upgrades to students and academic researchers \cite{GitHubForScience}. Accordingly, PyPackIT is built on top of GitHub, making use of its rich functionalities to provide a comprehensive environment for collaborative cloud development of research software.

Critical to PyPackIT's goals, in November 2019 GitHub introduced \href{https://github.com/features/actions}{GitHub Actions} (GHA), an event-driven cloud computing platform for execution of automated software development \href{https://docs.github.com/en/actions/using-workflows/about-workflows}{workflows} on configurable machines, in response to specific \href{https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows}{events} like various activities in the repository \cite{GitHubDevWorkflowAutoEcoBook, HandsOnGHA}. Shortly after its release, GHA became the most popular Continuous Integration (CI) service on GitHub, due to its generous free tier for public repositories, full integration with GitHub, and better hardware and software support \cite{RiseAndFallOfCIinGH, OnUsageAndMigrationOfCITools, OnUseOfGHA}. Moreover, GitHub's comprehensive \href{https://docs.github.com/en/rest}{REST} and \href{https://docs.github.com/en/graphql}{GraphQL} application programming interfaces (APIs) grant workflows full control of all repository components, enabling automation well beyond conventional CI practices \cite{DevPerceptionOfGHA, GitHubDevWorkflowAutoEcoBook}. To facilitate GHA workflow development, GitHub allows reusable components called \href{https://docs.github.com/en/actions/creating-actions/about-custom-actions}{Actions}, which act as building blocks for workflows, similar to software libraries. Developers can host Actions on public GitHub repositories and publish them on \href{https://github.com/marketplace}{GitHub Marketplace}, an indexing service allowing users to search for suitable options. However, implementing workflows and Actions is a non-trivial task, faced by challenges in tooling, resources, configuration, testability, debugging, maintenance, and security \cite{HowDoSoftDevsUseGHA, EvolutionOfGHAWorkflows, OnUseOfGHA, OnOutdatednessOfWorkflowsInGHA, AutoSecurityAssessOfGHAWorkflows}. Action reuse is also low, due to issues with compatibility, functionality, performance, and findability \cite{DevPerceptionOfGHA}. Therefore, while GHA's automation capabilities can greatly improve the software development process \cite{HowDoSoftDevsUseGHA, LetsSuperchargeWorkflows}, most projects only use it for basic tasks \cite{OnUseOfGHA}. On the other hand, PyPackIT makes extensive use of GHA features and implements specialized workflows and Actions according to research software needs. These cloud applications fully integrate with other repository components to create comprehensive automation pipelines that streamline numerous repetitive engineering and management tasks throughout the software life-cycle.

## Python Programming Language

The choice of programming language greatly influences software adoption and sustainability \cite{RolesOfCodeInCSE}. For scientific software, the language should be fast, stable, predictable, versatile, user-friendly, and well-known \cite{SoftDevEnvForSciSoft, PythonEcosystemSciComp}. While low-level languages like C and Fortran dominate legacy high-performance computing (HPC) due to their speed and hardware integration \cite{SoftEngForCompSci, UnderstandingHPCCommunity, SciCompGridlock}, they fall short in addressing the diverse needs of modern research software \cite{PythonEcosystemSciComp}. Additionally, their complexity can obstruct software extension and maintenance \cite{SoftEngForCompSci, SciCompGridlock}. Therefore, higher-level languages are advised to improve development, collaboration, and productivity \cite{SoftEngForCompSci, BestPracticesForSciComp}. Over the past decade, Python has emerged as the leading programming language for research software development \cite{SurveySEPracticesInScience2, AnalyzingGitHubRepoOfPapers, DevOpsInSciSysDev}, widely adopted by major organizations such as CERN \cite{IntroducingPythonAtCERN, PythonAtCERN} and NASA \cite{PythonAtNASA}, and instrumental in key scientific achievements \cite{PythonScientificSuccessStories}, including the discovery of gravitational waves \cite{GravWaveDiscovery} and black hole imaging \cite{BlackHoleImage}. Python is now the most recommended language for scientific computing due to its simplicity, versatility, and extensive ecosystem \cite{PythonBatteriesIncluded, PythonForSciComp, PythonForSciAndEng, PythonJupyterEcosystem, SciCompWithPythonOnHPC, PythonEcosystemSciComp, WhatMakesPythonFirstChoice}, which provides performance-optimized libraries for array programming \cite{NumPy}, fundamental algorithms \cite{SciPy}, data analysis \cite{pandas}, machine learning \cite{PyTorch, Top5MLLibPython, ScikitLearn}, image processing \cite{scikitImage}, visualization \cite{Matplotlib, Mayavi}, interactive distributed computing \cite{IPython, Jupyter, Jupyter2}, parallel programming \cite{DaskAndNumba, DaskApplications}, and domain-specific scientific applications \cite{Astropy, SunPy, Pangeo, MDAnalysis, Biopython, NIPY}. Python can readily handle complex tasks such as web integration and visualization, which are hard to address in low-level languages \cite{PythonEcosystemSciComp}, while bridging the performance gap via optimized compilers \cite{Cython, Numba, Pythran}, GPU run-time code generators \cite{PyCUDA}, and APIs for integrating low-level languages \cite{PythonForSciComp, PythonEcosystemSciComp}. This adaptability enables rapid prototyping of complex applications, allowing researchers to quickly evaluate various scientific models and efficiently optimize the best solution \cite{BestPracticesForSciComp}. The recent advancements in parallel distributed computing with Python \cite{SciCompWithPythonOnHPC, ParallelDistCompUsingPython, ScientistsGuideToCloudComputing, DemystPythonPackageWithCondaEnvMod, PythonAcceleratorsForHPC} and Jupyter \cite{DistWorkflowsWithJupyter} has even motivated large HPC communities to shift toward Python \cite{SoftEngForCompSci, InteractiveSupercomputingWithJupyter}. Therefore, PyPackIT is specialized in the production of research software in Python, and provides a complete infrastructure and development environment using the latest tools and standards in its ecosystem.

## FAIR Research Software

Research software is a valuable asset that can be readily reused as a building block in numerous computational studies. As software is complex and intangible in nature \cite{MythicalManMonth}, such studies cannot be replicated, verified, or built upon without full access to the underlying source code, input data, and parameters \cite{ReprodResearchInCompSci, AccessibleReproducibleResearch, BarelySufficientPracticesInSciComp, ShiningLight, PublishYourCode, CaseForOpenCompProg}. Despite this, research software has been rarely published \cite{BridgingTheChasm, CaseForOpenCompProg, 4SimpleRecs, PublishYourCode, CompSciError}, leading to controversies \cite{InfluentialPandemicSimulation} and retractions \cite{RetractionCOVID}, preventing software reuse \cite{SurveySEPracticesInScience, SciSoftwareAccuracy}, and forcing scientists to re-implement computational workflows from scratch in each new project \cite{ProblemsOfEndUserDevs, BetterSoftwareBetterResearch}, which is an error-prone process yielding low-quality results \cite{SurveySEPracticesInScience2, SoftEngForCompSci}. In response, widespread appeals have emerged for an open research culture, promoting transparency and reproducibility \cite{PublishYourCode, PromotingOpenResearch, ReprodResearchInCompSci, CaseForOpenCompProg, EnhancingReproducibility, ShiningLight, TroublingTrendsInSciSoftware}. While more publications now include links to source code and data, this is still strongly biased toward a handful of institutions working in specific computer science fields \cite{AnalyzingGitHubRepoOfPapers}. Common obstacles to publishing research software include the lack of efficient mechanisms and tools for packaging, distribution, and indexing \cite{CaseForOpenCompProg, SurveySEPracticesInScience, ReprodResearchInCompSci}, as well as code quality concerns and technical challenges to refactor, document, and maintain the software \cite{BarelySufficientPracticesInSciComp, BetterSoftwareBetterResearch, PublishYourCode}. To sustain scientific progress in CSE, it is thus crucial to address these challenges and ensure that research software is FAIR \cite{FAIR4RS}: findable, accessible, interoperable, and reusable. 

Regarding accessibility, many journals now mandate source code submissions for peer-review and public access \cite{RealSoftwareCrisis, DoesYourCodeStandUp, CaseForOpenCompProg, TowardReproducibleCompResearch, MakingDataMaximallyAvailable, JournalOfBioStatPolicy}. It is thus highly recommended to adopt an open-source model from start \cite{BetterSoftwareBetterResearch, PublishYourCode, SurveySEPracticesInScience, BarelySufficientPracticesInSciComp, BestPracticesInBioinfSoftware, POVHowOpenSciHelps, 4SimpleRecs, ELIXIRSoftwareManagementPlan, 10RuleForSoftwareInCompBio}, making the source code freely accessible under a permissive license \cite{BusinessOfOpenSource}. This provides a full record of activities that can be crucial in tracking progress and recognition, enables transparent peer review, promotes trust and adoption, leads to more citations, and improves software quality and sustainability by encouraging community collaboration \cite{SharingDetailedResData, BetterSoftwareBetterResearch, ShiningLight, PublishYourCode, CaseForOpenCompProg, 4SimpleRecs, POVHowOpenSciHelps, BestPracticesInBioinfSoftware, SurveySEPracticesInScience, 10SimpleRulesForOpenDevOfSciSoft, BarelySufficientPracticesInSciComp}. Furthermore, to facilitate findability, research software must be searchable by its functionalities and attributes \cite{10MetricsForSciSoftware}. This requires the distribution of software to related public indexing repositories, along with comprehensive metadata and identifiers \cite{WhatMakesCompSoftSuccessful, HowToSupportOpenSource, 10SimpleRulesForOpenDevOfSciSoft, ELIXIRSoftwareManagementPlan, SustainableResearchSoftwareHandOver, BarelySufficientPracticesInSciComp, 4SimpleRecs}. For reproducibility of research results, each distribution must be permanently available and uniquely indexed with a persistent global identifier that enables reliable citations, such as a Digital Object Identifier (DOI) \cite{BarelySufficientPracticesInSciComp, BestPracticesInBioinfSoftware, ELIXIRSoftwareManagementPlan, BestPracticesInBioinfSoftware, 4SimpleRecs}. To ensure the interoperability and reusability of research software, employing DRY (Don't Repeat Yourself) Principles is encouraged to modularize code into separate methods and routines, organized into a software library with a clear API \cite{FAIR4RS, 10MetricsForSciSoftware, SciSoftDevIsNotOxymoron, 5RecommendedPracticesForCompSci, BestPracticesForSciComp}. As review articles and scientific textbooks provide an overview of recent progress and established knowledge in a field, scientific libraries do the same for code, implementing state-of-the-art algorithms and well-known procedures for use in computational studies \cite{RolesOfCodeInCSE}. Packaging code into software libraries can also greatly simplify the setup process for users \cite{10RuleForSoftwareInCompBio, ELIXIRSoftwareManagementPlan, WhyJohnnyCantBuild}, which is a common problem in research software \cite{NamingThePainInDevSciSoft, CompSciError}. Therefore, PyPackIT is focused on the production of open-source and FAIR scientific Python libraries, and implements automated solutions to facilitate above-mentioned challenges, such as licensing, packaging, distribution, and indexing \cite{BarelySufficientPracticesInSciComp, ELIXIRSoftwareManagementPlan, SustainableResearchSoftwareHandOver, ShiningLight, 10RuleForSoftwareInCompBio}.

## Cloud-Native Development

As research software belongs to an evolving scientific inquiry process, determining the exact requirements and design specifications of the end product is usually not possible in advance \cite{SoftDevEnvForSciSoft, ProblemsOfEndUserDevs}. Consequently, traditional software development methodologies \cite{BalancingAgilityAndDiscipline} are not suitable for research software \cite{DevelopingSciSoft, SurveySEPracticesInScience, SoftEngForCompSci, DealingWithRiskInSciSoft}. Instead, cloud-native practices such as Agile development, Continuous software engineering, and DevOps are highly recommended \cite{AdoptingSoftEngConceptsInSciResearch, HowScientistsDevAndUseSciSoft, SurveySEPracticesInScience, LitRevAgileInSciSoftDev, BestPracticesForSciComp, SciSoftDevIsNotOxymoron}. Agile development \cite{AgileSoftDev, AgileSoftDevMethodAndPractices, AgileSoftDevEcosystems, AgileSoftDevBook} is based on iterative enhancement of software via short inspect-and-adapt cycles and frequent feedback loops, suitable for research software as it typically needs to be constantly modified and evaluated in an experimental manner \cite{WhenEngineersMetScientists, SoftDevEnvForSciSoft}. Embracing the uncertain and evolving nature of research software development \cite{SurveySEPracticesInScience}, Agile methodologies accommodate higher rates of change, allowing for frequent experimentation while reducing variance, complexity, cost, and risk in the development process. Synergistically, Continuous software engineering practices enable projects to stay abreast with the fast-paced nature of Agile methods through automation \cite{ContSoftEngineering, ContinuousSoftEng}. Most common are CI \cite{ExtremeProgExplained, CIBlogPost, EffectsOfCIOnSoftDev}, Continuous Delivery (CDE) \cite{DevDepSecCloudApp, CDReliableSoftReleaseBook, CDHugeBenefits}, and Continuous Deployment (CD) \cite{DeploymentProductionLine, CDatFacebook, CDatFBandOANDA}, which build on top of each other (abbreviated as CI/CD) to eliminate the need for dedicated testing and deployment teams, while increasing the integrity, scalability, security, and transparency of development and deployment pipelines. CI/CD has numerous benefits, including decreased errors, more efficient bug discovery and resolution, and a high level of control over applied changes, allowing projects to produce, release, and maintain higher quality software more rapidly, efficiently, and reliably \cite{UsageCostsAndBenefitsOfCI, CDatFacebook, CICDSystematicReview, EffectsOfCIOnSoftDev, QualityAndProductivityCI, ImpactOfCI, HighwaysToCD, CIImprovingSoftQualBook, ExpBenefitsOfCI, UncoveringBenefitsAndChallengesOfCI, CIBlogPost, ModelingCI, ContinuousSoftEng, ExtremeProgExplained, StairwayToHeaven, CDReliableSoftReleaseBook, CDatFBandOANDA, CDHugeBenefits, StudyImpactAdoptCIOnPR}. Furthermore, DevOps extends Agile and Continuous methodologies by bridging the gap between Development (Dev) and Operations (Ops) phases of the project through automation \cite{WhatIsDevOps}, which has proven useful in research software projects \cite{DevOpsInSciSysDev, ResearchOps}.

Considered crucial in collaborative and distributed software development \cite{EffectsOfCIOnSoftDev, CICDSystematicReview, AnalysisOfTrendsInProductivity}, cloud-native methodologies are widely established in the industry \cite{EmpEvAgile, AgileAdoptionSurvey, CDatFacebook, CDatFBandOANDA, Top10AdagesInCD, ContinuousSoftEng, UsageCostsAndBenefitsOfCI, CICDSystematicReview, HighwaysToCD, StairwayToHeaven, SynthCDPractices, RiseAndFallOfCIinGH, OnUsageAndMigrationOfCITools} and some large research institutes \cite{IntroducingAgileInBioInf, AgileInBioMedSoftDev, UsingAgileToDevCompBioSoft, ExploringXPForSciRes, DevOpsInSciSysDev}. However, their adoption is challenging \cite{ContSoftEngineeringBookStairway} and not prevalent in academia \cite{SurveySEPracticesInScience2, SelfPerceptions, AdoptingSoftEngConceptsInSciResearch}, where most scientists use an impromptu software development process that negatively impacts research software quality \cite{ProblemsOfEndUserDevs, DevelopingSciSoft, SurveySEPracticesInScience}. A major barrier to adoption is implementing Continuous pipelines, which is a complex and costly task \cite{StairwayToHeaven}, faced with challenges such as lack of consensus on a single well-defined standard and limited availability of tools, technologies, instructions, and resources \cite{ModelingCI, CICDSystematicReview, UncoveringBenefitsAndChallengesOfCI}. As ready-to-use solutions are not freely available \cite{CDHugeBenefits}, projects have to either use paid services or spend considerable amounts of time and resources to implement their own pipelines \cite{CICDSystematicReview, HowDoSoftDevsUseGHA, DevPerceptionOfGHA, EffectsOfCIOnSoftDev}. As a result, the majority of open-source projects do not follow Continuous practices \cite{CITheater}, or use outdated \cite{OnOutdatednessOfWorkflowsInGHA} and faulty pipelines that can compromise the development process and introduce security vulnerabilities into the project \cite{AutoSecurityAssessOfGHAWorkflows, AmbushFromAllSides}. Therefore, PyPackIT provides a comprehensive set of ready-to-use CI/CD pipelines according to engineering best practices \cite{HighwaysToCD, ExtremeProgExplained, OopsAnalysisOfTravisCI, ProblemsCausesSolutionsCD, CDSoftIntensive, OnRapidRelease, QualityAndProductivityCI, UsageCostsAndBenefitsOfCI, CIImprovingSoftQualBook, CIBlogPost, ModelingCI, UnderstandingSimilAndDiffinSoftDev, EffectsOfCIOnSoftDev, AgileSoftDevMethodAndPractices, ContinuousSoftEng, CICDSystematicReview}, which run on GHA to automate code integration and software deployment, enabling projects to readily adopt an Agile software development process tailored to research software needs.

## Pull-Based Workflow

Efficient and consistent production of high-quality software requires a well-established workflow to orchestrate the development process \cite{CollabSoftEngBookConcepts, StateOfArtInEndUserSoftEng}. The lack of a streamlined development workflow may be the main reason why research software projects often use a non-standard development process \cite{ProblemsOfEndUserDevs, DevelopingSciSoft, SurveySEPracticesInScience} and are faced with management and maintenance problems \cite{NamingThePainInDevSciSoft, ConfigManageForLargescaleSciComp}. Therefore, PyPackIT provides an automated development workflow based on a well-tested strategy for collaborative research software projects \cite{ConfigManageForLargescaleSciComp}. It uses distributed VCSs and issue tracking systems (ITSs) to establish a pull-based development model \cite{ExplorStudyPullBased, WorkPractPullBased}, which is a bottom-up approach that separates development from integration. It enables the community to spontaneously propose changes to the project via issue tickets and pull requests (PRs), while core maintainers are responsible for reviewing and integrating the work. This accelerates development by promoting community engagement \cite{CharacterizingProjEvolOnSocialCodingPlat}, and facilitates code reviews and feedback loops between developers and maintainers, which is recognized as one of the most effective and crucial quality assessment activities for research software development \cite{5RecommendedPracticesForCompSci, 10MetricsForSciSoftware, BestPracticesForSciComp}. However, pull-based development also requires significant management effort \cite{CharacterizingProjEvolOnSocialCodingPlat}, especially for larger projects \cite{SciSoftDevIsNotOxymoron}. For example, projects need a well-defined governance model that defines the responsibilities and privileges of each member, to facilitate continuous task assignment throughout the software life-cycle \cite{4SimpleRecs, SustainableResearchSoftwareHandOver}. Another crucial aspect is documenting the development process, including plans, requirements, design decisions, and implementation details \cite{WhatMakesCompSoftSuccessful, SciSoftDevIsNotOxymoron, 5RecommendedPracticesForCompSci, BestPracticesForSciComp, BestPracticesInBioinfSoftware}, to provide a clear overview of the project evolution to both users and collaborators, ensuring that the implementation matches the expected design, and preventing the loss of critical knowledge about the software \cite{DealingWithRiskInSciSoft, BestPracticesForSciComp}. 

ITSs, one of the most important tools for research software development, simplify pull-based development via functionalities for documentation, organization, and tracking of tasks in the project \cite{SurveySEPracticesInScience, BestPracticesForSciComp, DLRSoftEngGuidelines, 10RuleForSoftwareInCompBio, SciSoftDevIsNotOxymoron}. They offer a communication channel to systematically provide feedback, while recording a searchable history of all submitted issues and their corresponding information, which is crucial for thorough documentation of the software development process \cite{BarelySufficientPracticesInSciComp, ELIXIRSoftwareManagementPlan}. However, \href{https://github.com/features/issues}{GitHub Issues} (GHI), GitHub's free and well-integrated ITS, requires significant configuration and adjustment to enable these features. By default, it only offers a single option for opening issue tickets, asking users for a title and optional description in a free format. This lack of structure leads to problems such as missing crucial information in submitted tickets, which complicates triage for project maintainers \cite{EmpAnalysisOfIssueTemplatesOnGitHub}. To facilitate issue management, GitHub offers labeling features to help categorize, prioritize, and find tickets \cite{GiLaGitHubLabelAnalyzer, ExploringCharacIssueRelatedGitHub}. However, since ticket inputs are not machine readable, labeling must be done manually, which is an error-prone and time-consuming task \cite{WhereIsTheRoadForIssueReports}, and often neglected \cite{GotIssues, ExploringTheUseOfLabels}. Another problem is maintaining the links between tickets and the corresponding commits resolving the issues in the VCS, which is important for tracing changes back to their associated tickets and accompanied documentation and discussion \cite{ConfigManageForLargescaleSciComp}. These also need to be manually created and are often neglected \cite{FillingTheGapsOfDevLogs}, resulting in the loss of a large portion of the project's evolution history \cite{MissingLinksBugsAndBugFix}. Such problems have even motivated the development of machine-learning-based tools for automatic ticket classification \cite{PredictingIssueTypesOnGitHub, ImpactOfDataQualityForAutomaticIssueClassification} and issue–commit link recovery \cite{IssueCommitLink-DeepLink, FRLink}. Recently, GitHub also added new templating features to GHI, allowing projects to define separate submission options for issue types, which improves ticket organization and reduces triage workload for developers \cite{FirstLookAtBugReportTempOnGitHub, UnderstandingIssueTemplateOnGitHub}. Moreover, in 2021 GitHub introduced \href{https://github.blog/changelog/2021-06-23-issues-forms-beta-for-public-repositories/}{issue forms}, enabling projects to build structured web forms with rich input types such as dropdown menus, checkboxes, and text fields. This allows the collection of required user inputs in a structured and machine-readable format and leads to significant improvements in resolution time \cite{EmpAnalysisOfIssueTemplatesOnGitHub}. PyPackIT makes extensive use of these features to streamline its pull-based development workflow. It offers fully designed issue forms based on best practices \cite{WhatMakesAGoodBugReport, NeedsInBugReports, QualityOfBugReportsInEclipse}, and uses their inputs to automate activities like ticket labeling and organization, task assignment, documentation, and creating issue–commit links.

Another important aspect of the development workflow are version control practices \cite{10MetricsForSciSoftware, ELIXIRSoftwareManagementPlan} such as branching, which provides isolation for simultaneous development and maintenance of multiple software versions \cite{ImportanceOfBranchingModels}. For example, to support cloud-native development, short-lived branches are used to implement new changes, which are then merged into stable branches that contain production-ready code \cite{CICDSystematicReview}. While crucial for software development, branching is considered one of the most problematic practices of VCSs \cite{EffectOfBranchingStrategies}. The suitability of a branching model is also project-dependent, resulting in a variety of different strategies \cite{BranchUseInPractice}. Although several well-established models exist \cite{TrunkBasedDev, GitFlow, GitHubFlow, GitLabFlow}, they are not fully aligned with the needs of research software, which is typically first released as a proof-of-concept prototype and can undergo multiple significant changes after its initial publication \cite{UnderstandingHPCCommunity}. This requires a branching model that enables the development, release, and long-term maintenance of multiple versions of the software in parallel, to facilitate rapid evolution while ensuring the reproducibility and sustainability of the scientific results based on earlier releases \cite{ConfigManageForLargescaleSciComp}. In accordance with these requirements, PyPackIT includes automated version control in the development workflow, complete with a specialized branching model and version scheme.

## Quality Assurance and Testing

Given the integral role of computational studies in solving critical real-life problems, ensuring the reliability and correctness of scientific software is of utmost importance. As software bugs can lead to incorrect scientific results \cite{CompSciError}, software testing is one of the most crucial practices in research software development \cite{BestPracticesForSciComp, 5RecommendedPracticesForCompSci, BestPracticesInBioinfSoftware, SurveySEPracticesInScience, ELIXIRSoftwareManagementPlan, DLRSoftEngGuidelines}. It is highly recommended to use test-driven development methodologies and perform frequent testing from the beginning of the development cycle, thus preventing the accumulation of errors into complex problems \cite{10SimpleRulesOnWritingCleanAndReliableSciSoft, SciSoftDevIsNotOxymoron, SurveySEPracticesInScience}. This is especially important for research software \cite{EmpStudyDesignInHPC}, in which deviations from expected behavior may also occur due to the underlying scientific model, making it harder to identify the root cause of problems \cite{SoftDevEnvForSciSoft}. Thus, unit tests must be written parallel to code implementation, verifying the accuracy of individual code components in isolation \cite{BarelySufficientPracticesInSciComp}. They can also be used in regression testing, which is crucial for ensuring that features remain functional after each modification \cite{10SimpleRulesOnWritingCleanAndReliableSciSoft, BestPracticesForSciComp}. To ensure testing effectiveness, test coverage metrics must be monitored to identify code components and software functionalities that are not covered by the available test cases \cite{DLRSoftEngGuidelines, 10SimpleRulesOnWritingCleanAndReliableSciSoft}. To improve reproducibility and increase trust in the software \cite{ELIXIRSoftwareManagementPlan, DLRSoftEngGuidelines}, users must also be able to run the tests on their machines to asses the functionality and performance of their local installation \cite{10MetricsForSciSoftware, BestPracticesInBioinfSoftware}. To facilitate this, all tests and corresponding data should be organized into a software package \cite{BestPracticesInBioinfSoftware}, called test suite, and distributed along instructions on how to run it and information about the testing methodology \cite{BarelySufficientPracticesInSciComp, 10MetricsForSciSoftware}.

In addition to testing, static code analysis tools such as linters and type checkers must also be used to check for violations and other potential issues in the code \cite{DLRSoftEngGuidelines, BestPracticesForSciComp}. These tools help with refactoring as well, improving code quality, performance, and maintainability \cite{SurveySEPracticesInScience, 10SimpleRulesOnWritingCleanAndReliableSciSoft}. Moreover, to facilitate readability, which is a key factor in collaboration and peer review \cite{BestPracticesForSciComp}, code formatting tools must be used to establish a consistent coding style according to best practices \cite{BestPracticesForSciComp, NLeScienceSoftDevGuide}. Importantly, to ensure that these practices are consistently performed, they must be automated in the project's development workflow \cite{BestPracticesForSciComp, 10MetricsForSciSoftware, 10SimpleRulesOnWritingCleanAndReliableSciSoft}. This is a challenging task that often prevents adequate code quality assurance and testing \cite{StairwayToHeaven}, specially in research software projects \cite{TestingResearchSoftwareSurvey, SoftEngForCompSci} as they lack management support \cite{SurveySEPracticesInScience} and skills in modern software engineering and testing methodologies  \cite{HowScientistsDevAndUseSciSoft, SurveySEPracticesInScience2, ProblemsOfEndUserDevs}. Consequently, while more than half of scientists' programming time is spent on debugging code \cite{SurveySEPracticesInScience2}, only primitive methods are used that are slow, ineffective, and prone to errors \cite{SurveySEPracticesInScience2, SoftEngForCompSci, SurveySEPracticesInScience}. As code quality assurance and testing practices are usually neglected \cite{CompSciError, ProblemsOfEndUserDevs, SurveySEPracticesInScience2, SoftwareChasm}, research software may contain inapparent issues that do not interrupt the execution of the program, but result in incorrect outputs that compromise scientific findings \cite{CompSciError}. Such errors have caused numerous retractions \cite{NightmareRetraction, RetractionChang, RetractionMa, RetractionChang2, RetractionJAmCollCardiol, RetractionMeasuresOfCladeConfidence, RetractionsEffectOfAProgram}, corrections \cite{CorrectionHypertension}, and comments \cite{CommentOnError, CommentOnError2, CommentOnError3, CommentOnError4, CommentOnError5, ClusterFailureFMRI}, even in high-profile publications. Therefore, there is a current need for promoting and facilitating standard code analysis, formatting, and testing practices in research software engineering \cite{TestingResearchSoftwareSurvey, ApproxTowerInCompSci, SoftEngForCompSci} Accordingly, PyPackIT offers a fully automated quality assurance and testing infrastructure for the entire development life-cycle, fulfilling all requirements, including coverage monitoring, documentation, and test-suite distribution.

## Documentation

One of the main determining factors of software quality and success is documentation \cite{HowToSupportOpenSource, 10SimpleRulesForOpenDevOfSciSoft, BestPracticesForSciComp, GoodEnoughPracticesInSciComp, DLRSoftEngGuidelines, NLeScienceSoftDevGuide, SurveySEPracticesInScience, WhatMakesCompSoftSuccessful}. It must provide clear information on how to install and execute the software, how each part works, and how to use them correctly, thus ensuring that the capabilities and limitations of the software are understood and exploited in the intended way by its users \cite{WhatMakesCompSoftSuccessful, SciSoftDevIsNotOxymoron, ELIXIRSoftwareManagementPlan, SurveySEPracticesInScience, NamingThePainInDevSciSoft, CompSciError, BestPracticesInBioinfSoftware, BarelySufficientPracticesInSciComp, 10RuleForSoftwareInCompBio}. This is especially important for research software, where knowledge about the project is continuously lost \cite{EmpStudyDesignInHPC, SoftwareSustainabilityInstitute} due to high developer turnover rates \cite{RecommendOnResearchSoftware}. Moreover, as the software evolves, it is crucial to document all important changes in each new release compared to its earlier version. This information must be published along each release, allowing users to evaluate the update impact on their projects. Additionally, it must be recorded chronologically in a so-called \href{https://keepachangelog.com}{changelog}, providing an overview of the software evolution to new users and contributors \cite{ELIXIRSoftwareManagementPlan, GoodEnoughPracticesInSciComp, SustainableResearchSoftwareHandOver}. As building a community is crucial for research software success \cite{WhatMakesCompSoftSuccessful}, equally important as user documentation is providing collaborators with project information \cite{SurveySEPracticesInScience, BestPracticesForSciComp, BestPracticesInBioinfSoftware} including contribution guidelines, governance model, and code of conduct \cite{SustainableResearchSoftwareHandOver, GoodEnoughPracticesInSciComp, 4SimpleRecs, ELIXIRSoftwareManagementPlan}. 

Producing and maintaining high-quality documentation requires significant time, effort, and skills \cite{SurveySEPracticesInScience}. In addition to writing large amounts of content, developers typically need to design, develop, and deploy a website to present the documentation in an accessible, coherent, and user-friendly format \cite{WhatMakesCompSoftSuccessful}. This is a non-trivial task, requiring a broad knowledge of web development concepts and tools, including HTML, CSS, and JavaScript, as well as web hosting services and practices. Moreover, the documentation website must always reflect the latest state of the project, requiring developers to periodically update and maintain it after each change. To facilitate software documentation, several tools and practices have been developed \cite{TenSimpleRulesForDocumentingSciSoft}. For example, it is recommended to embed the documentation of code components next to their source code, as specially annotated comments called docstrings \cite{WhatMakesCompSoftSuccessful, BestPracticesForSciComp}. The developers can then use a static site generator like \href{https://www.sphinx-doc.org}{Sphinx} to generate a website that includes the library's API documentation, automatically extracted from these comments \cite{SurveySEPracticesInScience, TenSimpleRulesForDocumentingSciSoft}. While such tools can greatly simplify the process, developers still need to invest a lot of time and effort to find, learn, set up, and configure them. Consequently, research software is typically not well-documented \cite{CompSciError, SoftEngForCompSci, ProblemsOfEndUserDevs, AnalyzingGitHubRepoOfPapers, DealingWithRiskInSciSoft}. This is one of the most common barriers to using available research software \cite{HowScientistsReallyUseComputers, HowScientistsDevSciSoftExternalRepl}, a typical cause of software misuse leading to faulty scientific results \cite{CompSciError}, and one of the main reasons why researchers refrain from publishing their software \cite{InfluentialPandemicSimulation, BetterSoftwareBetterResearch}. Therefore, PyPackIT puts great emphasis on documentation, providing infrastructure and automated solutions that enable projects to maintain high-quality documentation with minimal effort.

## Maintenance

Modern research software can often remain useful and operational for decades \cite{SoftwareSustainabilityInstitute, SoftEngForCompSci}. Thus, considering the amounts of time and effort required to develop high-quality software, it is important to sustain the available options \cite{BarelySufficientPracticesInSciComp}. This requires active maintenance \cite{SoftEngForCompSci}: The project must continuously receive feedback from its community to fix existing issues, improve functionalities, and add missing features \cite{SoftwareSustainabilityInstitute}. This is more crucial for research software, which also needs to reflect scientific advances \cite{SoftDevEnvForSciSoft}. Maintaining software dependencies \cite{FortyYearsOfSoftwareReuse} is another important aspect \cite{EmpComparisonOfDepNetEvolution}: To facilitate usability, scientific software libraries must be compatible with diverse computer environments, requiring them to remain functional with future dependency versions. However, most projects are unaware of their outdated dependencies and do not update them regularly \cite{DoDevsUpdateDeps}, leading to incompatibilities, bugs, and other issues in the software \cite{MeasuringDepFreshness, ThouShaltNotDepend, OnImpactOfSecVulnInDepNet}. Research software maintenance is particularly hindered by short-term funding options \cite{ManagingChaos, BetterSoftwareBetterResearch}, small team sizes \cite{SoftEngForCompSci, HowScientistsReallyUseComputers}, high turnover rates \cite{RecommendOnResearchSoftware, EmpStudyDesignInHPC}, and the fact that it does not lead to new publications \cite{SoftEngForCompSci}. Another main barrier is technical debt \cite{BetterSoftwareBetterResearch, ProblemsOfEndUserDevs, SoftEngForCompSci}: Neglecting software engineering best practices during the development considerably increases the workload of performing new tasks \cite{ManagingTechnicalDebt}, causing each new modification to further increase the software entropy \cite{10SimpleRulesForOpenDevOfSciSoft, SoftDesignForEmpoweringSci} and create new technical debt, making maintenance increasingly harder \cite{ManagingChaos, SoftwareSustainabilityInstitute}. Consequently, the extra time and effort required for maintenance is one of the main reasons for not publicly releasing research software \cite{BetterSoftwareBetterResearch, PublishYourCode}, which is often abandoned as an unsustainable prototype, not usable in future research projects \cite{SustainableResearchSoftwareHandOver, 10RuleForSoftwareInCompBio, PublishYourCode}. To prevent these issues, quality assurance and maintenance tasks should be automated and enforced from the beginning of the project \cite{SoftEngForCompSci}. PyPackIT achieves this by several mechanisms, including its automated pull-based development model that promotes collaboration and feedback, CI/CD pipelines that enforce software engineering best practices throughout the development process, and Continuous Maintenance (CM) \cite{ContinuousMaintenance}, Refactoring (CR) \cite{ContRefact}, and Testing (CT) \cite{ContinuousSoftEng} pipelines (abbreviated as CM/CR/CT) that periodically perform various automated tasks, such as updating dependencies and development tools, to maintain the health of the software and its development environment.

## Configuration

Software projects usually contain multiple data files
declaring metadata and settings for different project components.
The requirement for each tool to have its own configuration file 
in a specific format and location complicates maintenance and organization. 
Additionally, redundancy arises as some data is reused within and across projects, 
hindering the rapid and reliable modification of configurations \cite{BestPracticesForSciComp}. 
Manual adjustments via interactive interfaces further complicate configuration tracking and replicability, 
making consistent production and management of software projects a challenge \cite{DevOpsInSciSysDev}. 
To solve such issues, DevOps practices such as Infrastructure-as-Code (IaC) 
and Continuous Configuration Automation (CCA) have been developed to enable dynamic configuration management 
of software infrastructures using machine-readable definition files \cite{InfrastructureAsCode}. 
PyPackIT implements a similar mechanism to facilitate the definition, customization, synchronization, 
and maintenance of all project metadata and settings. 
It provides a user-friendly control center that renders the entire project infrastructure 
and development environment dynamic, enabling automatic project management and configuration.
