import argparse
import json

import actionman
from loggerman import logger

import proman
from proman import script, report
from proman.report import initialize_logger


def cli():
    initialize_logger()
    kwargs, token_manager = _read_args()
    reporter = report.Reporter(github_context=kwargs.get("github_context"))
    manager = proman.manager(
        token_manager=token_manager,
        reporter=reporter,
        repo_path=kwargs["repo"],
        commit_hash=kwargs.get("commit_hash"),
        validate_metadata=kwargs.get("validate_metadata", True),
    )
    endpoint = _get_endpoint(kwargs.pop("endpoint"))
    endpoint(kwargs | {"manager": manager})
    return


def _read_args() -> argparse.Namespace:
    """Read inputs and return them as a namespace object."""
    args = _parse_args()
    github_context = json.loads(
        args.github_context
    ) if "github_context" in args else actionman.env_var.read(
        "GITHUB_CONTEXT", typ=dict, remove=args.remove_tokens
    )
    if github_context:
        github_token = github_context.pop("token")
        args.github_context = github_context
        if github_token:
            args.github_token = github_token
    kwargs = vars(args)
    token_manager = proman.token_manager(
        github=kwargs.pop("github_token", None),
        github_admin=kwargs.pop("github_admin_token", None),
        zenodo=kwargs.pop("zenodo_token", None),
        zenodo_sandbox=kwargs.pop("zenodo_sandbox_token", None),
        remove_from_env=args.remove_tokens,
    )
    logger.debug("Input Arguments", kwargs | {"token_manager": token_manager})
    return kwargs, token_manager


def _get_endpoint(endpoint_name: str):
    def get_recursive(parts, current_object):
        if len(parts) == 1:
            return getattr(current_object, parts[0])
        return get_recursive(parts[1:], getattr(current_object, parts[0]))

    parts = endpoint_name.split(".")
    return get_recursive(parts, script)


def _parse_args() -> argparse.Namespace:
    """Generate the command line interface for the project manager and parse input arguments.

    Notes
    -----
    The code for this function is automatically generated by the control center.
    """
    # begin auto-generated parser
    parser = argparse.ArgumentParser(description="Project Manager CLI")
    parser.add_argument("--repo", help="Local path to the repository root directory.", default="./")
    parser.add_argument("--github-token", help="GitHub token for accessing the repository.")
    parser.add_argument("--remove-tokens", help="Remove all tokens read from the environment.", action="store_true")
    parser.add_argument("--no-validation", action="store_false", dest="validate_metadata")
    # Sub-parsers for parser
    subparsers_main = parser.add_subparsers(dest="command", required=True)
    subparser_cca = subparsers_main.add_parser("cca", help="Run Continuous Configuration Automation on the repository.")
    subparser_cca.add_argument("-b", "--branch-version", help="Branch-name to version mappings (e.g., -b main=0.0.0 dev=1.0.0a1) to use instead of git tags.", type=str, nargs="*", metavar="BRNACH=VERSION")
    subparser_cca.add_argument("-p", "--control-center", help="Path to the control center directory containing configuration files.", type=str)
    subparser_cca.add_argument("-d", "--dry-run", help="Perform a dry run without making any changes.", action="store_true")
    subparser_cca.add_argument("-c", "--clean-state", help="Skip validation of the metadata.json file.", action="store_true")
    subparser_cca.set_defaults(endpoint="cca.run_cli")
    subparser_lint = subparsers_main.add_parser("lint", help="Run pre-commit hooks on the repository.")
    subparser_lint.add_argument("-x", "--action", help="Lint mode.", type=str, choices=['report', 'run', 'validate'], default="run")
    subparser_lint.add_argument("-c", "--config", help="Path to the pre-commit configuration file.", type=str, default=".devcontainer/config/pre-commit.yaml")
    subparser_lint.add_argument("-r2", "--to-ref", help="Run on files changed until the given git ref. This must be accompanied by --from-ref.")
    subparser_lint_mutually_exclusive_hook = subparser_lint.add_mutually_exclusive_group()
    subparser_lint_mutually_exclusive_hook.add_argument("-i", "--hook-id", help="Specific hook ID to run. This will only run the specified hook.", type=str)
    subparser_lint_mutually_exclusive_hook.add_argument("-s", "--hook-stage", help="Specific hook stage to run. This will only run hooks in the specified stage.", type=str)
    subparser_lint_mutually_exclusive_file = subparser_lint.add_mutually_exclusive_group()
    subparser_lint_mutually_exclusive_file.add_argument("-a", "--all-files", help="Run on all files in the repository.", action="store_true")
    subparser_lint_mutually_exclusive_file.add_argument("-f", "--files", help="Run on specific files.", nargs="+")
    subparser_lint_mutually_exclusive_file.add_argument("-r1", "--from-ref", help="Run on files changed since the given git ref. This must be accompanied by --to-ref.")
    subparser_lint.set_defaults(endpoint="lint.run_cli")
    subparser_version = subparsers_main.add_parser("version", help="Print the current version of the project.")
    subparser_version.set_defaults(endpoint="version.run_cli")
    subparser_build = subparsers_main.add_parser("build", help="Build project components.")
    # Sub-parsers for subparser_build
    subparsers_build = subparser_build.add_subparsers(dest="build", required=True)
    subparser_conda = subparsers_build.add_parser("conda", help="Build a conda package in the project.")
    subparser_conda.add_argument("-p", "--pkg", help="Package ID, i.e., the `pypkg_` key suffix in configuration files.", default="main")
    subparser_conda.add_argument("-o", "--output", help="Path to the local conda channel directory.", type=str, default=".local/temp/conda-channel")
    subparser_conda.add_argument("-r", "--recipe", help="Type of recipe to build.", type=str, choices=['local', 'global'], default="local")
    subparser_conda.add_argument("--args", help="Additional arguments to pass to the conda build command.", nargs=argparse.REMAINDER)
    subparser_conda.set_defaults(endpoint="build.conda.run_cli")
    subparser_python = subparsers_build.add_parser("python", help="Build a Python package in the project.")
    subparser_python.add_argument("-p", "--pkg", help="Package ID, i.e., the `pypkg_` key suffix in configuration files.", default="main")
    subparser_python.add_argument("-o", "--output", help="Path to the local PyPI channel directory.", type=str, default=".local/temp/wheelhouse")
    subparser_python.add_argument("--args", help="Additional arguments to pass to the Python build command.", nargs=argparse.REMAINDER)
    subparser_python.set_defaults(endpoint="build.python.run_cli")
    subparser_render = subparsers_main.add_parser("render", help="Render documents in the project.")
    # Sub-parsers for subparser_render
    subparsers_render = subparser_render.add_subparsers(dest="render", required=True)
    subparser_pypi = subparsers_render.add_parser("pypi", help="Render package README file for PyPI.")
    subparser_pypi.add_argument("-p", "--pkg", help="Package ID, i.e., the `pypkg_` key suffix in configuration files.", default="main")
    subparser_pypi.add_argument("-o", "--output", help="Output directory to write the rendered HTML file.", type=str, default=".local/temp/readme-pypi")
    subparser_pypi.set_defaults(endpoint="render.pypi.run_cli")
    subparser_gha = subparsers_main.add_parser("gha", help="Run CI/CD pipelines in GitHub Actions.")
    subparser_gha.set_defaults(endpoint="gha.run_cli")
    # Process inputs
    args = parser.parse_args()
    if args.command == "cca":
        if args.branch_version:
            try:
                args.branch_version = dict(pair.split("=", 1) for pair in args.branch_version)
            except ValueError:
                parser.error(
                    "--branch-version must be in the format BRANCH=VERSION (e.g., -b main=1.0.0 dev=2.0.0)."
                )
    if args.command == "lint":
        if (args.from_ref and not args.to_ref) or (args.to_ref and not args.from_ref):
            parser.error("Both --from-ref and --to-ref must be provided together.")
    # end auto-generated parser
    return args


if __name__ == "__main__":
    cli()
