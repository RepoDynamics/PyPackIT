import argparse
import json

import actionman
from loggerman import logger

from proman import script
from proman.report import initialize_logger


def cli():
    def get_endpoint(endpoint_name: str):
        def get_recursive(parts, current_object):
            if len(parts) == 1:
                return getattr(current_object, parts[0])
            else:
                return get_recursive(parts[1:], getattr(current_object, parts[0]))

        parts = endpoint_name.split(".")
        return get_recursive(parts, script)

    initialize_logger()
    args = _read_args()
    logger.debug("Input Arguments", args)
    endpoint = get_endpoint(args.endpoint)
    endpoint(args)
    return


def _read_args() -> argparse.Namespace:
    """Read inputs and return them as a namespace object."""
    args = _parse_args()
    _set_github_context(args)
    _set_github_token(args)
    _set_github_admin_token(args)
    _set_zenodo_token(args)
    _set_zenodo_sandbox_token(args)
    return args


def _set_github_context(args: argparse.Namespace) -> None:
    args.github_context = json.loads(
        args.github_context
    ) if "github_context" in args else actionman.env_var.read("GITHUB_CONTEXT", typ=dict, remove=args.remove_tokens)
    if args.github_context:
        github_token = args.github_context.pop("token")
        if github_token:
            args.github_token = github_token
    return


def _set_github_token(args: argparse.Namespace) -> None:
    if "github_token" in args:
        return
    for env_var_name in ("GITHUB_TOKEN", "GITHUB_ADMIN_TOKEN"):
        token = actionman.env_var.read(env_var_name, typ=str, remove=args.remove_tokens)
        if token:
            args.github_token = token
            return
    token = _pyshellman.run(
        command=["gh", "auth", "token"],
        logger=logger,
        raise_execution=False,
        raise_exit_code=False,
        raise_stderr=False,
    ).out
    if token:
        args.github_token = token
    return


def _set_github_admin_token(args: argparse.Namespace) -> None:
    if "github_admin_token" in args:
        return
    for env_var_name in ("GITHUB_ADMIN_TOKEN", ):
        token = actionman.env_var.read(env_var_name, typ=str, remove=args.remove_tokens)
        if token:
            args.github_admin_token = token
            return
    if "github_token" in args:
        args.github_admin_token = args.github_token
    return


def _set_zenodo_token(args: argparse.Namespace) -> None:
    if "zenodo_token" in args:
        return
    args.zenodo_token = actionman.env_var.read("ZENODO_TOKEN", typ=str, remove=args.remove_tokens)
    return


def _set_zenodo_sandbox_token(args: argparse.Namespace) -> None:
    if "zenodo_sandbox_token" in args:
        return
    args.zenodo_sandbox_token = actionman.env_var.read("ZENODO_SANDBOX_TOKEN", typ=str, remove=args.remove_tokens)
    return


def _parse_args() -> argparse.Namespace:
    """Generate the command line interface for the project manager and parse input arguments.

    Notes
    -----
    The code for this function is automatically generated by the control center.
    """
    # begin auto-generated parser
    parser = argparse.ArgumentParser(description="Project Manager CLI")
    parser.add_argument("--repo", type=str, help="Local path to the repository root directory.", default="./")
    # Sub-parsers for parser
    subparsers_main = parser.add_subparsers(dest="command", required=True)
    subparser_cca = subparsers_main.add_parser("cca", help="Run Continuous Configuration Automation on the repository.")
    subparser_cca.add_argument("-t", "--github-token", type=str, help="GitHub token for accessing the repository.")
    subparser_cca.add_argument("-b", "--branch-version", help="Branch-name to version mappings (e.g., -b main=0.0.0 dev=1.0.0a1) to use instead of git tags.", type=str, nargs="*", metavar="BRNACH=VERSION")
    subparser_cca.add_argument("-c", "--control-center", help="Path to the control center directory containing configuration files.", type=str)
    subparser_cca.add_argument("-d", "--dry-run", help="Perform a dry run without making any changes.", action="store_true")
    subparser_cca.add_argument("-n", "--no-validate", help="Skip validation of the metadata.json file.", dest="validate", action="store_false")
    subparser_cca.set_defaults(endpoint="cca.run_cli")
    subparser_lint = subparsers_main.add_parser("lint", help="Run pre-commit hooks on the repository.")
    subparser_lint.add_argument("-x", "--action", help="Lint mode.", type=str, choices=['report', 'run', 'validate'], default="run")
    subparser_lint.add_argument("-c", "--config", help="Path to the pre-commit configuration file.", type=str, default=".devcontainer/config/pre-commit.yaml")
    subparser_lint.add_argument("-r2", "--to-ref", help="Run on files changed until the given git ref. This must be accompanied by --from-ref.")
    subparser_lint_mutually_exclusive_hook = subparser_lint.add_mutually_exclusive_group()
    subparser_lint_mutually_exclusive_hook.add_argument("-i", "--hook-id", help="Specific hook ID to run. This will only run the specified hook.", type=str)
    subparser_lint_mutually_exclusive_hook.add_argument("-s", "--hook-stage", help="Specific hook stage to run. This will only run hooks in the specified stage.", type=str)
    subparser_lint_mutually_exclusive_file = subparser_lint.add_mutually_exclusive_group()
    subparser_lint_mutually_exclusive_file.add_argument("-a", "--all-files", help="Run on all files in the repository.", action="store_true")
    subparser_lint_mutually_exclusive_file.add_argument("-f", "--files", help="Run on specific files.", nargs="+")
    subparser_lint_mutually_exclusive_file.add_argument("-r1", "--from-ref", help="Run on files changed since the given git ref. This must be accompanied by --to-ref.")
    subparser_lint.set_defaults(endpoint="lint.run_cli")
    subparser_version = subparsers_main.add_parser("version", help="Print the current version of the project.")
    subparser_version.set_defaults(endpoint="version.run_cli")
    subparser_build = subparsers_main.add_parser("build", help="Build project components.")
    # Sub-parsers for subparser_build
    subparsers_build = subparser_build.add_subparsers(dest="build", required=True)
    subparser_conda = subparsers_build.add_parser("conda", help="Build a conda package in the project.")
    subparser_conda.add_argument("-p", "--pkg", help="Package ID, i.e., the `pypkg_` key suffix in configuration files.", default="main")
    subparser_conda.add_argument("-o", "--output", help="Path to the local conda channel directory.", type=str, default=".local/temp/conda-channel")
    subparser_conda.add_argument("-r", "--recipe", help="Type of recipe to build.", type=str, choices=['local', 'global'], default="local")
    subparser_conda.add_argument("--args", help="Additional arguments to pass to the conda build command.", nargs=argparse.REMAINDER)
    subparser_conda.set_defaults(endpoint="build.conda.run_cli")
    subparser_python = subparsers_build.add_parser("python", help="Build a Python package in the project.")
    subparser_python.add_argument("-p", "--pkg", help="Package ID, i.e., the `pypkg_` key suffix in configuration files.", default="main")
    subparser_python.add_argument("-o", "--output", help="Path to the local PyPI channel directory.", type=str, default=".local/temp/wheelhouse")
    subparser_python.add_argument("--args", help="Additional arguments to pass to the Python build command.", nargs=argparse.REMAINDER)
    subparser_python.set_defaults(endpoint="build.python.run_cli")
    subparser_render = subparsers_main.add_parser("render", help="Render documents in the project.")
    # Sub-parsers for subparser_render
    subparsers_render = subparser_render.add_subparsers(dest="render", required=True)
    subparser_pypi = subparsers_render.add_parser("pypi", help="Render package README file for PyPI.")
    subparser_pypi.add_argument("-p", "--pkg", help="Package ID, i.e., the `pypkg_` key suffix in configuration files.", default="main")
    subparser_pypi.add_argument("-o", "--output", help="Output directory to write the rendered HTML file.", type=str, default=".local/temp/readme-pypi")
    subparser_pypi.set_defaults(endpoint="render.pypi.run_cli")
    subparser_gha = subparsers_main.add_parser("gha", help="Run CI/CD pipelines in GitHub Actions.")
    subparser_gha.set_defaults(endpoint="gha.run_cli")
    # Process inputs
    args = parser.parse_args()
    import json
    from pathlib import Path
    setattr(
        args,
        "metadata",
        json.loads((Path(args.repo).resolve() / ".github/.repodynamics/metadata.json").read_text())
    )
    if args.command == "cca":
        if args.branch_version:
            try:
                args.branch_version = dict(pair.split("=", 1) for pair in args.branch_version)
            except ValueError:
                parser.error(
                    "--branch-version must be in the format BRANCH=VERSION (e.g., -b main=1.0.0 dev=2.0.0)."
                )
    if args.command == "lint":
        if (args.from_ref and not args.to_ref) or (args.to_ref and not args.from_ref):
            parser.error("Both --from-ref and --to-ref must be provided together.")
    # end auto-generated parser
    return args


if __name__ == "__main__":
    cli()
