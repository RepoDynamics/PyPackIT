__temp__:
  conda_recipe:
    path:
      local: ${{ ..path.root }}$/conda-recipe/local
      global: ${{ ..path.root }}$/conda-recipe/global
    meta:
      values:
        build:
          values:
            script:
              - value: '{{ PYTHON }} -m pip install {{ pkg_dir }} --no-deps --no-build-isolation -vv'
        requirements:
          values:
            host:
              values:
                  - value: python ${{ pkg.python.version.spec }}$
                  - value: pip
                  - '*{{ #{{ return hook.conda_req("host") }}# }}*'
            run:
              values:
                - value: python ${{ pkg.python.version.spec }}$
                - '*{{ #{{ return hook.conda_req("run") }}# }}*'
            run_constrained:
              values:
                - '*{{ #{{ return hook.conda_req("run_constrained") }}# }}*'
        test:
          values:
            imports:
              values:
                - |
                  *{{
                    #{{
                      out = []
                      for entry in get("..entry.python", {}).values():
                        conda = entry["conda"]
                        if not conda:
                          continue
                        entry = {"value": entry["name"]}
                        if conda is not True:
                          entry["selector"] = conda
                        out.append(entry)
                      return out
                    }}#
                  }}*
            requires:
              values:
                - value: pip
            commands:
              values:
                - value: pip check
                - |
                  *{{
                    #{{
                      out = []
                      for key in ("cli", "gui"):
                        for entry in get(f"..entry.{key}", {}).values():
                          conda = entry["conda"]
                          if not conda:
                            continue
                          entry = {"value": f"{entry["name"]} --help"}
                          if conda is not True:
                            entry["selector"] = conda
                          out.append(entry)
                      return out
                    }}#
                  }}*
        about:
          home: ${{ web.url.home }}$
          license: ${{ license.expression }}$
          license_file:
            - '{{ pkg_dir }}${{ __data__.dir_name.licenses }}$/'
            - |
              *{{
                #{{
                  if not any(
                    component["path"].get("header_plain")
                    for component in get("license.component", {}).values()
                  ):
                    return []
                  return [f'{{{{ pkg_dir }}}}{get("__data__.dir_name.copyrights")}/']
                }}#
              }}*
          summary: ${{ title }}$
          dev_url: ${{ repo.url.home }}$
          doc_url: ${{ web.url.home }}$
          doc_source_url: ${{ document.readme.output.pkg.url }}$
        extra:
          recipe-maintainers: |
            #{{
                return [
                  member["github"]["id"] for member in team_members_with_role_types(
                    "ProjectManager",
                    active_only=True,
                  )
                ]
            }}#

  pyproject:
    build-system:
      build-backend: setuptools.build_meta
      requires: >-
        #{{ return hook.pyproject_dependency("build") }}#
    project:
      name: ${{ .name }}$
      description: ${{ title }}$
      readme:
        file: README.md
        content-type: text/markdown
      requires-python: ${{ .python.version.spec }}$
      license: ${{ license.expression }}$
      license-files: [ '${{ __data__.dir_name.licenses }}$/*', '${{ __data__.dir_name.copyrights }}$/*' ]
      authors: |
        #{{
          return [
            hook.entity_in_pyproject(author)
            for author in (
              team_members_with_role_types("Author", active_only=True)
              + changelog.current_public.contributors_with_role_types("Author", member=False)
            )
          ]
        }}#
      maintainers: |
        #{{
          return [
            hook.entity_in_pyproject(maintainer)
            for maintainer in team_members_with_role_types(
              ["ContactPerson", "ProjectManager", "DataManager", "ProjectLeader", "Supervisor"],
              active_only=True,
            )
          ]
        }}#
      keywords: ${{ keywords }}$
      classifiers:
        - 'Natural Language :: ${{ language.name }}$'
        - '*{{ #{{ return hook.trove_classifiers() }}# }}*'
      urls:
        Homepage: ${{ web.url.home }}$
        Documentation: ${{ web.page.manual.url }}$
        Source: ${{ repo.url.home }}$
        Download: ${{ repo.url.releases.home }}$
        News: ${{ web.page.blog.url }}$
        Issue-Tracker: ${{ repo.url.issues.home }}$
      scripts: >-
        #{{ return hook.pyproject_scripts("cli") }}#
      gui-scripts: >-
        #{{ return hook.pyproject_scripts("gui") }}#
      entry-points: >-
        #{{ return hook.pyproject_entry_points() }}#
      dependencies: >-
        #{{ return hook.pyproject_dependency("core") }}#
      optional-dependencies: >-
        #{{ return hook.pyproject_dependency("optional") }}#
      dynamic: [ version ]
    tool:
      setuptools:
        packages:
          find:
            where: [ '${{ .path.source_rel }}$' ]
            namespaces: true
        include-package-data: true
        cmdclass:
          build_py: versioningit.cmdclass.build_py
          sdist: versioningit.cmdclass.sdist
      versioningit:
        vcs:
          method: git
          match: [ '${{ tag.version.prefix }}$[0-9]*.[0-9]*.[0-9]*' ]
          default-tag: ${{ tag.version.prefix }}$0.0.0
        tag2version:
          rmprefix: ${{ tag.version.prefix }}$
        format:
          distance: '{base_version}+{distance}.{committer_date:%Y.%m.%d}.{rev}'
          dirty: '{base_version}+0.{committer_date:%Y.%m.%d}.{rev}.dirty'
          distance-dirty: '{base_version}+{distance}.{committer_date:%Y.%m.%d}.{rev}.dirty'
        onbuild:
          method: replace-version
          regex: '^__version_details__: dict\[str, str\] = (?P<version>.*)'
          require-match: true
          source-file: '${{ .path.source_rel }}$/${{ .import_name }}$/__init__.py'
          build-file: '${{ .import_name }}$/__init__.py'
          replacement: >-
            {{
            "version": "{version}",
            "build_date": "{build_date:%Y.%m.%d}",
            "committer_date": "{committer_date:%Y.%m.%d}",
            "author_date": "{author_date:%Y.%m.%d}",
            "branch": "{branch}",
            "distance": "{distance}",
            "commit_hash": "{revision}"
            }}