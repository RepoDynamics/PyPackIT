title: Cloud-Native Continuous Software Engineering Automation for Python Projects
  # Alternative Titles
  # - A fully automated, plug and play, professional software project management solution for Python packages on GitHub
  # - GitHub-Based Automation Tool For Research Software Engineering in Python
  # - Cloud-Based Automation for Research Software on GitHub
  # - Cloud-Based Automation For Scientific Python Libraries on GitHub
  # - A ready-to-use automation tool for research software development in Python on GitHub
  # - A cloud-based automation tool for scientific Python libraries on GitHub
  # - A fully automated tool for better research software development
  # - Solving (Tackling) the research software crisis with automation (on GitHub)
  # - Automated research software development with Python packages on GitHub
  # - A fully automated scientific software project management solution/system for Python packages on GitHub
  # - Better Research Software in Python with Automation on GitHub
  # - Toward Better Research Software with Python Packages and Automation on GitHub
abstract: >-
  ${{ name }}$ ${{ __custom__.name_ipa }}$
  is a comprehensive <strong>cloud-based automation tool</strong>
  for production of <abbr title="Findable, Accessible, Interoperable, and Reusable">FAIR</abbr>
  and professional software on <strong>GitHub</strong>,
  in accordance with the latest engineering best practices and standards.
  It is a ready-to-use software suite that streamlines the initiation, configuration,
  development, publication, management, and maintenance of high-quality software libraries in <strong>Python</strong>.
  By taking charge of repetitive tasks and automatically enforcing best practices
  throughout the software development life-cycle,
  ${{ name }}$ enables users to solely focus on the creative aspects of their projects,
  while improving quality and lowering production costs.
  Using state-of-the-art tools and methodologies, ${{ name }}$ offers a robust project infrastructure,
  including a build-ready Python <strong>package skeleton</strong>,
  a fully operational <strong>test suite</strong>, a complete <strong>documentation website</strong>,
  and a comprehensive <strong>control center</strong> facilitating Continuous Configuration Automation (CCA)
  and dynamic project management.
  ${{ name }}$ establishes a complete <strong>cloud-native development</strong> environment on GitHub,
  integrating with its version control system, issue tracker,
  and pull-based model to provide a fully automated software development workflow,
  complete with features like <strong>issue management</strong>, <strong>branching model</strong>, and <strong>version scheme</strong>.
  Leveraging <strong>GitHub Actions</strong> (GHA), ${{ name }}$ implements a cloud-native development process
  with specialized Continuous Integration (CI), Deployment (CD), Testing (CT), Refactoring (CR),
  and Maintenance (CM) pipelines, using <strong>Agile</strong>, <strong>Continuous software engineering</strong>,
  and <strong>DevOps</strong> methodologies.
  ${{ name }}$ is a free and open-source software suite that readily integrates with
  both new and existing projects to ensure their long-term sustainability and high quality,
  thus enabling developers to rapidly implement their ideas and easily maintain their software.
keywords:
  - Automation
  - Cloud-Native Development
  - Continuous Integration
  - Continuous Delivery
  - Continuous Deployment
  - Continuous Testing
  - Continuous Refactoring
  - Continuous Configuration Automation
  - Continuous Software Engineering
  - DevOps
  - Infrastructure as Code
  - Agile
  - Dynamic Project Management
  - Template Repository
  - Python Package Skeleton
  - Sphinx Website
  - Test Suite Skeleton
  - FAIR Software
  - GitHub Actions
  - Bot
highlights:
  - title: Ready to Use
    description: |
      ${{ name }}$ is fully preconfigured and readily installed
      in both new and existing repositories,
      requiring most users to only fill project-specific metadata.
      PyPackIT then takes over, automatically setting up the repository
      and generating a complete infrastructure for the project
      where the only remaining steps in the software development process are
      adding your code, unit-tests, and documentation content.
  - title: Customizability and Dynamism
    description: |
      While fully configured out of the box, ${{ name }}$ is highly customizable,
      allowing users to tailor every aspect of their project
      and development pipeline to their specific needs.
      ${{ name }}$'s control center provides detailed configuration options
      in a declarative format, while enabling the dynamic generation of custom specifications
      and metadata during runtime. These can be used to generate and augment
      other configurations and files, rendering the entire project dynamic and eliminating redundancy.
  - title: Cloud Development
    description: |
      ${{ name }}$ is a cloud-based solution that integrates with GitHub
      and uses GitHub Actions to automate the software development process.
      It provides a cloud-native development environment that
      eliminates the need for initial setup and configuration,
      enabling users to immediately begin the actual
      implementation of software, even directly from the web browser.
      This promotes collaboration, which is essential for project sustainability.
  - title: Continuous Configuration Automation
    description: |
      ${{ name }}$ provides a centralized user interface
      based on <strong>DevOps</strong> practices like <strong>Infrastructure-as-Code</strong> (IaC)
      to enable Continuous Configuration Automation (CCA)
      for the entire project. ${{ name }}$'s control center
      simplifies project configuration, customization, and management
      via automatic data <strong>templating</strong> and <strong>augmentation</strong>, cross-repository <strong>inheritance</strong>,
      and <strong>synchronization</strong> features that instantly apply modifications to all project components.
  - title: Python Package
    description: |
      ${{ name }}$ includes a fully-configured and build-ready
      package skeleton automatically maintained via the control center.
      Users only need to add application code in the provided source files,
      while PyPackIT automates all integration, packaging, and deployment tasks.
      To facilitate software findability and usage,
      each new release is published to GitHub, PyPI, and Zenodo,
      with a persistent DOI ensuring reproducibility and reliable citations.
  - title: Test Suite
    description: |
      ${{ name }}$'s fully operational testing infrastructure enables the
      immediate adoption of test-driven methodologies,
      requiring users to only provide test cases in the provided skeleton.
      Testing is then automatically performed throughout the development life-cycle,
      while improving awareness of software health status via notifications and reports.
      The test suite is automatically packaged and distributed along each release,
      allowing for verification of software functionality and performance by its users.
  - title: Documentation Website
    description: |
      ${{ name }}$ offers an automated solution for maintaining
      a comprehensive documentation website, requiring users to
      simply provide docstrings. A fully designed website
      is included, prefilled with content that is automatically customized
      with project-specific information and continuously complemented
      throughout the development process. The website is
      automatically deployed to GitHub Pages and ReadTheDocs,
      requiring no web development knowledge.
  - title: Version Control
    description: |
      ${{ name }}$ fully integrates with Git to automate tasks
      like branch and commit management, versioning, tagging, and merging.
      It implements a specialized branching model and version scheme
      for simultaneous publication and support of multiple releases,
      thus enabling rapid project evolution according to Agile
      and Continuous software engineering methodologies,
      while ensuring the availability and sustainability of earlier releases.
  - title: Issue Management
    description: |
      ${{ name }}$ dynamically maintains the project's issue tracking system,
      providing type-specific submission forms designed according to best practices.
      These collect user inputs in a structured and machine-readable format,
      allowing ${{ name }}$ to automate issue management activities
      such as ticket formatting, labeling and organization, task assignment,
      design documentation, issue–commit linkage, and progress monitoring.
      ${{ name }}$ can also execute tests from issue comments, greatly simplifying bug triage.
  - title: Continuous Integration & Deployment
    description: |
      PyPackIT's CI/CD pipelines automate tasks such as code style formatting,
      static code analysis, type checking, testing, dependency monitoring,
      versioning, packaging, build, release, and distribution.
      They eliminate the need for dedicated integration
      and deployment teams, while increasing control, integrity, scalability, security,
      and transparency of the Agile development process.
  - title: Continuous Refactoring & Testing
    description: |
      ${{ name }}$ ensures long-term project sustainability by
      periodically performs automated testing, refactoring, and maintenance tasks
      such as testing previous releases with updated dependencies,
      analyzing and formatting code according to the latest standards,
      upgrading development tools and project infrastructure,
      and maintaining the health of the project and its development environment
      by automatically creating issues and pull requests for applying updates and fixes.
  - title: Copyright & Licensing
    description: |
      ${{ name }}$ is fully integrated with the SPDX license standard and
      supports all SPDX License List entries as well as user-defined licenses.
      Projects can define complex licenses simply by providing an SPDX expression.
      ${{ name }}$ will then automatically retrieve the required license data,
      customize it with project-specific information,
      produce visually appealing and valid license files,
      and integrate license information into all project components and releases.
  - title: Security & Transparency
    description: |
      ${{ name }}$ improves project security while supporting community collaboration
      by incorporating security measures like branch/tag protection,
      vulnerability scanning, dependency monitoring, and private security advisories.
      All workflows and Actions are developed according to the latest security standards
      to prevent unauthorized access, data breaches, and code injection attacks.
      To ensure that ${{ name }}$ itself is highly secure,
      its entire infrastructure is natively implemented and self-contained.
license:
  expression: AGPL-3.0-or-later
role:
  manager:
    title: Project Manager
    description: |
      Responsible for maintaining the project and its resources.
    abbreviation: MGR
    type: ProjectManager
    assignment:
      issue: ".*"
      review: ".*"
  author:
    title: Author
    description: |
      Responsible for creating the project and its content.
    abbreviation: AUT
    type: Author
    assignment:
      pull: ".*"
  contact:
    title: Contact Person
    description: |
      Responsible for communication with project users and contributors.
    abbreviation: CNT
    type: ContactPerson
    assignment:
      discussion: ".*"
  security:
    title: Security Adviser
    description: |
      Responsible for ensuring the security of the project and
      handling security-related issues.
    abbreviation: SEC
    type: ProjectMember
  coc:
    title: Code of Conduct Supervisor
    description: |
      Responsible for ensuring that the project's code of conduct is enforced.
    abbreviation: COC
    type: ProjectMember
team:
  aariam:
    github:
      id: AAriam
    role:
      manager: 1
      author: 1
      contact: 1
      security: 1
      coc: 1
citation:
  cff:
    authors: |
      #{{
        return [
          {"id": int_author["id"], "member": True}
          for int_author in team_members_with_role_types("Author", active_only=True)
        ] + [
          {"id": ext_author["id"], "member": False}
          for ext_author in changelog.current_public.contributors_with_role_types("Author", member=False)
        ]
      }}#
    contacts: |
      #{{
          return [
            member["id"] for member in team_members_with_role_types(
              "ContactPerson",
              active_only=True,
            )
          ]
      }}#
    doi: |
      #{{
        curr_changelog = changelog.current_public
        return curr_changelog.get("release", {}).get(
          "zenodo_sandbox" if curr_changelog.get("ongoing") else "zenodo", {}
        ).get("doi")
      }}#
    version: >-
      #{{ return changelog.current_public.get("version") }}#
    date_released: >-
      #{{ return changelog.current_public.get("date") }}#
    commit: >-
      #{{ return changelog.current_public.get("commit", {}).get("sha") }}#
    repository:
      build: ${{ pkg.pypi.url.home }}$
    identifiers:
      - |
        *{{
          #{{
            out = []
            concept_doi = get("var.zenodo.concept.doi")
            if concept_doi:
              entry = {
                "type": "doi",
                "value": concept_doi,
                "description": "Persistent DOI of the project as a whole."
              }
              out.append(entry)
            return out
          }}#
        }}*
  zenodo:
    license: '#{{ return get("citation.cff.license")[0] }}#'
    keywords: ${{ citation.cff.keywords }}$
    related_identifiers:
      - |
        *{{
          #{{
            last_doi = changelog.last_public.get("release", {}).get("zenodo", {}).get("doi")
            out = [
              {
                "identifier": doi,
                "relation": relation,
                "resource_type": get("..upload_type")
              } for doi, relation in [
                (get("var.zenodo.concept.doi"), "isPartOf"),
                (last_doi, "isNewVersionOf"),
              ] if doi
            ]
            return out
          }}#
        }}*
    contributors: |
      #{{
        out = []
        for role_type in (
          "RightsHolder",
          "Producer",
          "Distributor",
          "Sponsor",
          "RegistrationAgency",
          "RegistrationAuthority",
          "HostingInstitution",
          "Supervisor",
          "ProjectLeader",
          "WorkPackageLeader",
          "ContactPerson",
          "ProjectManager",
          "DataManager",
          "Editor",
          "ResearchGroup",
          "Researcher",
          "DataCurator",
          "DataCollector",
          "ProjectMember",
          "RelatedPerson",
          "Other",
        ):
          for is_member in (True, False):
            for contributor in changelog.current_public.contributors_with_role_types(role_type, member=is_member):
              out.append({"id": contributor["id"], "member": is_member, "role_types": role_type})
          for member in team_members_with_role_types(role_type, active_only=True):
            entry = {"id": member["id"], "member": True, "role_types": role_type}
            if entry not in out:
              out.append(entry)
        return out
      }}#
    custom:
      code:programmingLanguage:
        - id: python
      code:developmentStatus:
        id: >-
          #{{ return "concept" if get("version", "").startswith("0") else "active" }}#
__custom__:
  name_ipa: "[ˈpaɪˌpækɪt]"
