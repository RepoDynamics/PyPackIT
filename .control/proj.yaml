title: Cloud-Native Continuous Software Engineering Automation for Python Packages on GitHub
  # Alternative Titles
  # - A fully automated, plug and play, professional software project management solution for Python packages on GitHub
  # - GitHub-Based Automation Tool For Research Software Engineering in Python
  # - Cloud-Based Automation for Research Software on GitHub
  # - Cloud-Based Automation For Scientific Python Libraries on GitHub
  # - A ready-to-use automation tool for research software development in Python on GitHub
  # - A cloud-based automation tool for scientific Python libraries on GitHub
  # - A fully automated tool for better research software development
  # - Solving (Tackling) the research software crisis with automation (on GitHub)
  # - Automated research software development with Python packages on GitHub
  # - A fully automated scientific software project management solution/system for Python packages on GitHub
abstract: >-
  ${{ name }}$ [ˈpaɪˌpækɪt]
  is a comprehensive <strong>cloud-based automation tool</strong>
  for production of <abbr title="Findable, Accessible, Interoperable, and Reusable">FAIR</abbr>
  and professional applications on <strong>GitHub</strong>,
  in accordance with the latest software engineering best practices and standards.
  ${{ name }}$ is a ready-to-use software suite
  that streamlines the initiation, configuration, development, publication, management,
  and maintenance of high-quality <strong>Python applications</strong>.
  By taking charge of repetitive tasks
  and automatically enforcing best practices
  throughout the software development life cycle,
  ${{ name }}$ enables users to solely focus
  on the creative aspects of their projects,
  while improving quality and lowering production costs.
  Using latest tools and methodologies, ${{ name }}$ offers a robust project infrastructure,
  including a build-ready Python <strong>package skeleton</strong>,
  a fully operational <strong>test suite</strong>,
  an automated <strong>documentation website</strong>,
  and a comprehensive <strong>control center</strong>
  according to <strong>Infrastructure-as-Code</strong>
  and <strong>Continuous Configuration Automation</strong> practices
  to enable dynamic project management and customization.
  ${{ name }}$ establishes a complete <strong>cloud development</strong> environment on GitHub,
  integrating with its version control system, issue tracker,and pull-based model
  to provide a fully <strong>automated software development workflow</strong>
  with <strong>issue management</strong>,
  <strong>branching model</strong>, and <strong>versioning scheme</strong>.
  Leveraging <strong>GitHub Actions</strong>,
  ${{ name }}$ implements a cloud-native Agile development process
  using <strong>Continuous software engineering</strong>, <strong>containerization</strong>,
  and <strong>DevOps</strong> methodologies,
  with a full set of <strong>Continuous Integration</strong>, Deployment, Testing, Refactoring,
  and Maintenance pipelines.
  ${{ name }}$ is a <strong>free</strong> and <strong>open-source</strong> software suite
  that readily integrates with both new and existing projects
  to ensure their long-term sustainability and high quality,
  enabling software projects to rapidly implement their ideas
  and easily maintain their products.
keywords:
  - Automation
  - Cloud-Native Development
  - Continuous Integration
  - Continuous Delivery
  - Continuous Deployment
  - Continuous Testing
  - Continuous Refactoring
  - Continuous Configuration Automation
  - Continuous Software Engineering
  - DevOps
  - Infrastructure as Code
  - Agile
  - Dynamic Project Management
  - Template Repository
  - Python Package Skeleton
  - Sphinx Website
  - Testing Infrastructure
  - FAIR Software
  - GitHub Actions
  - Bot
highlights:
  - title: Ready to Use
    description: |
      ${{ name }}$ is fully preconfigured and easily installable
      in both new and existing repositories via a GitHub repository template.
      Most users only need to invest a few minutes filling project-specific information
      in the provided configuration files.
      PyPackIT then takes over, setting up the repository
      and generating a complete infrastructure and fully automated development workflow for the project.
      This leaves users with only few tasks throughout the software development life cycle,
      such as adding application code, unit-tests, and minimal documentation content.
  - title: Cloud Native Development
    description: |
      ${{ name }}$ is a cloud-based solution that integrates with GitHub
      and uses GitHub Actions to automate the entire software development process.
      It provides a cloud-native development environment that
      eliminates the need for initial setup and configuration,
      enabling users to immediately begin with the actual
      implementation of software, even directly from the web browser.
      All integration, testing, and deployment tasks are automatically carried out on the cloud,
      facilitating Agile development and ensuring the consistent enforcement of best practices.
  - title: Continuous Configuration Automation
    description: |
      ${{ name }}$ offers a centralized user interface
      for automatic configuration, customization, and management
      of the entire project, and even multiple projects at once.
      Based on DevOps practices like Infrastructure-as-Code,
      ${{ name }}$'s control center consolidates all project configurations
      into a unified data structure, supporting both declarative definitions
      and dynamic data generation at runtime via built-in templating, scripting,
      and online retrieval features.
      Configurations are automatically applied to related components,
      eliminating redundancy and rendering the entire project dynamic.
  - title: Continuous Integration & Deployment
    description: |
      ${{ name }}$'s CI/CD pipelines automate tasks such as code analysis,
      style formatting, type checking, refactoring, testing, dependency monitoring,
      versioning, build, containerization, release, and distribution,
      with support for multiple indexing repositories including PyPI, Anaconda,
      Zenodo, GitHub Releases, and all Docker registries.
      These Continuous software engineering pipelines eliminate the need for dedicated integration
      and deployment teams, while increasing control, integrity, scalability, security,
      and transparency of the Agile development process.
  - title: Continuous Refactoring & Testing
    description: |
      ${{ name }}$ provides Continuous pipelines that
      periodically perform automated testing, refactoring, and maintenance tasks
      such as testing previous releases with up-to-date dependencies,
      refactoring code according to the latest standards,
      upgrading development tools and project infrastructure,
      and cleaning up the repository and its development environment.
      ${{ name }}$ can automatically submit issue tickets and pull requests
      for applying updates and fixes, thus maintaining
      the health of the project and ensuring its long-term sustainability.
  - title: Issue Management
    description: |
      ${{ name }}$ automatically maintains the project's issue tracking system,
      providing type-specific submission forms that are
      kept up-to-date with project information.
      These collect user inputs in a structured format,
      allowing ${{ name }}$ to automate issue management activities
      such as ticket formatting, labeling, bug triage, task assignment,
      documentation, issue–commit linkage, and progress reports.
      Users can also command ${{ name }}$ to perform specific tasks using semantic comments and labels,
      eliminating all repetitive issue management activities.
  - title: Version Control
    description: |
      ${{ name }}$ fully integrates with Git and GitHub
      to automate version control tasks like branching,
      versioning, tagging, commit management, and merging.
      Based on well-established models such as Git Flow,
      ${{ name }}$ adopts a specialized branching strategy and version scheme
      for simultaneous development and deployment of multiple orthogonal release candidates,
      ${{ name }}$'s strategy enables rapid project evolution according to Agile
      and Continuous software engineering methodologies,
      while ensuring availability and long-term support of earlier releases.
  - title: Python Application
    description: |
      ${{ name }}$ supports Python applications with extension modules and non-Python dependencies.
      It enables deployment as a Python package, a Conda package,
      and/or a Docker image to cloud services such as PyPI,
      Anaconda, Docker registries, and BinderHub instances.
      ${{ name }}$ includes a build-ready package skeleton with essential source files
      and automatically maintained configuration files customized for the project.
      Users only need to add application code in the provided source files,
      while ${{ name }}$ automates all integration, packaging, and deployment tasks.
  - title: Test Suite
    description: |
      ${{ name }}$'s fully automated testing infrastructure enables the
      immediate adoption of test-driven development methodologies,
      requiring users to only provide test cases in the provided skeleton files.
      Testing is then automatically performed at various phases of the development life cycle,
      while generating comprehensive reports and coverage metrics
      to improve awareness of software health status.
      The test suite is automatically packaged and distributed along each release,
      allowing for local verification of software functionality and performance by its users.
  - title: Documentation Website
    description: |
      ${{ name }}$ includes a fully designed website
      filled with automatically generated documentation such as
      project information, package metadata, installation guides,
      API reference, changelogs, release notes,
      contribution guides, and citation data.
      The website is automatically deployed to GitHub Pages and Read The Docs platforms,
      and can be easily customized via the control center with no web development knowledge.
      ${{ name }}$ can also dynamically generate standalone documents in various Markdown formats,
      such as READMEs for different repositories.
  - title: Copyright & Licensing
    description: |
      ${{ name }}$ incorporates the System Package Data Exchange (SPDX) license standard
      and supports all SPDX License List licenses and exceptions, as well as user-defined ones.
      Projects can define complex licenses simply by providing an SPDX license expression.
      ${{ name }}$ will then automatically retrieve
      the necessary data from the SPDX database,
      customize it with project-specific information,
      generate visually appealing and syntactically valid license files and copyright notices,
      and integrate license information into all project components and releases.
  - title: Security & Transparency
    description: |
      ${{ name }}$ improves project security while supporting community collaboration
      by incorporating security measures like branch and tag protection rulesets,
      vulnerability scanning, dependency monitoring, and private security advisories.
      All provided GitHub Actions workflows and applications are developed
      according to the latest security standards
      to prevent unauthorized access, data breaches, and code injection attacks.
      To ensure that ${{ name }}$ is highly secure and transparent,
      most of its infrastructure is natively implemented and self-contained.
license:
  expression: AGPL-3.0-or-later
role:
  manager:
    title: Project Manager
    description: |
      Responsible for maintaining the project and its resources.
    abbreviation: MGR
    type: ProjectManager
    assignment:
      issue: ".*"
      review: ".*"
  author:
    title: Author
    description: |
      Responsible for creating the project and its content.
    abbreviation: AUT
    type: Author
    assignment:
      pull: ".*"
  contact:
    title: Contact Person
    description: |
      Responsible for communication with project users and contributors.
    abbreviation: CNT
    type: ContactPerson
    assignment:
      discussion: ".*"
  security:
    title: Security Adviser
    description: |
      Responsible for ensuring the security of the project and
      handling security-related issues.
    abbreviation: SEC
    type: ProjectMember
  coc:
    title: Code of Conduct Supervisor
    description: |
      Responsible for ensuring that the project's code of conduct is enforced.
    abbreviation: COC
    type: ProjectMember
team:
  aariam:
    github:
      id: AAriam
    email:
      id: armiariam@gmail.com
    role:
      manager: 1
      author: 1
      contact: 1
      security: 1
      coc: 1
zenodo:
  license: '#{{ return get("file_citation_cff.content.license")[0] }}#'
  keywords: '#{{ return get("keywords") }}#'
  related_identifiers:
    - |
      *{{
        #{{
          last_doi = manager.changelog.last_public.get("release", {}).get("zenodo", {}).get("doi")
          out = [
            {
              "identifier": doi,
              "relation": relation,
              "resource_type": get("..upload_type")
            } for doi, relation in [
              (get("zenodo.concept.doi"), "isPartOf"),
              (last_doi, "isNewVersionOf"),
            ] if doi
          ]
          return out
        }}#
      }}*
  contributors: |
    #{{
      out = []
      for role_type in (
        "RightsHolder",
        "Producer",
        "Distributor",
        "Sponsor",
        "RegistrationAgency",
        "RegistrationAuthority",
        "HostingInstitution",
        "Supervisor",
        "ProjectLeader",
        "WorkPackageLeader",
        "ContactPerson",
        "ProjectManager",
        "DataManager",
        "Editor",
        "ResearchGroup",
        "Researcher",
        "DataCurator",
        "DataCollector",
        "ProjectMember",
        "RelatedPerson",
        "Other",
      ):
        for is_member in (True, False):
          for contributor in manager.changelog.current_public.contributors_with_role_types(role_type, member=is_member):
            out.append({"id": contributor["id"], "member": is_member, "role_types": role_type})
        for member in hook.members_with_role_types(role_type, active_only=True):
          entry = {"id": member["id"], "member": True, "role_types": role_type}
          if entry not in out:
            out.append(entry)
      return out
    }}#
  custom:
    code:programmingLanguage:
      - id: python
    code:developmentStatus:
      id: >-
        #{{ return "concept" if get("version", "").startswith("0") else "active" }}#
file_citation_cff:
  name: CFF Citation
  summary: >-
    [`CITATION.cff`](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-citation-files) file.
  description: |
    Citation file for the project
    in the [Citation File Format](https://citation-file-format.github.io/) (CFF).
    Current schema version is [CFF v1.2.0](https://github.com/citation-file-format/citation-file-format/blob/main/schema-guide.md).
  type: yaml
  path: CITATION.cff  # GitHub only supports `CITATION.cff` at root.
  content:
    message: Please cite ${{ name }}$ using the following references.
    title: |-
      #{{
        name = get("name")
        title = get("title")
        return f"{name}: {title}" if title else name
      }}#
    authors: |-
      #{{
        # Get all members and contributors with the role type "Author".
        authors = hook.members_with_role_types(
          "Author", active_only=True
        ) + manager.changelog.current_public.contributors_with_role_types("Author", member=False)
        # Transform each author data into a CFF person/entity object.
        return [hook.create_cff_person_or_entity(author) for author in authors]
      }}#
    contact: |-
      #{{
          return [
            hook.create_cff_person_or_entity(member) for member in hook.members_with_role_types(
              "ContactPerson",
              active_only=True,
            )
          ]
      }}#
    doi: |
      #{{
        # Get the latest DOI from the last/current public release on Zenodo.
        curr_changelog = manager.changelog.current_public
        return curr_changelog.get("release", {}).get(
          "zenodo_sandbox" if curr_changelog.get("ongoing") else "zenodo", {}
        ).get("doi")
      }}#
    version: >-
      #{{ return manager.changelog.current_public.get("version") }}#
    date-released: >-
      #{{ return manager.changelog.current_public.get("date") }}#
    commit: >-
      #{{ return manager.changelog.current_public.get("commit", {}).get("sha") }}#
    identifiers:
      - |
        *{{
          #{{
            out = []
            concept_doi = get("zenodo.concept.doi")
            if concept_doi:
              entry = {
                "type": "doi",
                "value": concept_doi,
                "description": "Persistent DOI of the project as a whole."
              }
              out.append(entry)
            return out
          }}#
        }}*
    license: |-
      #{{
        return [
          component["id"] for component in get("license.component", {}).values()
          if component["type"] == "license" and not component["custom"]
        ]
      }}#
    url: >-
      #{{ return get("web.url.home") or get("repo.url.home") }}#
    type: software
    keywords: >-
      #{{ return get("keywords") }}#
    abstract: >-
      #{{ return get("abstract") }}#
    repository-code: ${{ repo.url.home }}$
    repository-artifact: ${{ repo.url.releases.home }}$
    repository: null
    cff-version: 1.2.0
  content_setting:
    filter:
      remove_nulls:
        # Remove all top-level keys with `null` values (created by templates).
        # This removes optional values that are not set, keeping the file valid.
        jsonpath: "$.*"
    order:
      - message
      - preferred-citation
      - doi
      - commit
      - version
      - date-released
      - license
      - license-url
      - url
      - repository
      - repository-artifact
      - repository-code
      - identifiers
      - type
      - title
      - authors
      - contact
      - abstract
      - keywords
      - references
      - cff-version
  jsonschema:
    schema: !ext https://citation-file-format.github.io/1.2.0/schema.json
file_funding_github:
  name: GitHub Funding
  summary: GitHub [`FUNDING.yml`](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/displaying-a-sponsor-button-in-your-repository) file.
  status: inactive  # Change to "active" to enable the file.
  description: |
    Configurations for GitHub to display a sponsor button in the repository.
    Clicking on the button opens the ***Sponsor this project*** section,
    where a list of links to the specified funding platforms is displayed to the user.
  type: yaml
  path: .github/FUNDING.yml
  path_schema:
    description: |
      GitHub only recognizes this file at `.github/FUNDING.yml`.
    pattern: ^\.github/FUNDING\.yml$
  jsonschema:
    schema:
      $ref: https://jsonschemata.repodynamics.com/config/github/funding
  content:
    # See the schema or the GitHub documentation for the supported funding platforms.
    github:
      - ${{ team.owner.github.id }}$
dois: |
    #{{
      out = []
      preferred = get("file_citation_cff.content.preferred_citation", {})
      preferred_doi = preferred.get("doi")
      name = get("name")
      if preferred_doi:
        description = f"{name} paper in {preferred.get("journal") or preferred.get("publisher")}"
        out.append({"value": preferred_doi, "description": description})
      zenodo_concept_doi = get("zenodo.concept.doi")
      if zenodo_concept_doi:
        description = f"{name} immutable record on Zenodo"
        out.append({"value": zenodo_concept_doi, "description": description})
      latest_doi = get("file_citation_cff.content.doi")
      if latest_doi:
        description = f"{name} latest release (v{get("file_citation_cff.content.version")})"
        out.append({"value": latest_doi, "description": description})
      return out
    }}#
